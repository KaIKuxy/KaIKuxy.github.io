<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[POJ 2393 GreedyAlgorithm]]></title>
      <url>https://kaikuxy.github.io/2017/04/04/poj-2393/</url>
      <content type="html"><![CDATA[<p>贪心</p>
<p>每个星期可以制作无限数量的酸奶，每个星期有一个客户酸奶需求量Yi和单位酸奶制作花费Ci，酸奶可以以每个星期每单位S的花费无限储存。问如何花费最少满足所有客户需求量。</p>
<p>第i个星期若采用前面第j个星期时制作的酸奶，需满足式子</p>
<blockquote>
<p>Ci <em> Yi &gt; Cj </em> Yi + S <em> Yi </em> (i - j)</p>
<p>↓</p>
<p>Ci - Si &gt; Cj - Sj</p>
</blockquote>
<p>维护一个nowleast为当前星期前Cx - Sx的最小值以及那个星期编号num，更新ans。</p>
<pre><code class="C++">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#define Maxn 10000
using namespace std;

int n , s;
long long ans;
int c[Maxn + 10], y[Maxn + 10];
int nowleast, num;

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;s);
    nowleast = -1;
    for (int i = 1;i &lt;= n;++ i) {
        scanf(&quot;%d%d&quot;, &amp;c[i], &amp;y[i]);
        if (nowleast == -1 || nowleast &gt;= c[i] - s * i ) {
            nowleast = c[i] - s * i;
            num = i;
            ans = ans + c[i] * y[i];
            //printf(&quot;change to %d : num %d\nans : %lld\n&quot;, nowleast, num, ans);
        }
        else {
            ans = ans + c[num] * y[i] + s * (i - num) * y[i];
            //printf(&quot;use nowleast %d : num %d\nans : %lld\n&quot;, nowleast, num, ans);
        }
    }
    printf(&quot;%lld\n&quot;, ans);
    return 0;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> POJ </category>
            
            <category> GreedyAlgorithm </category>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> POJ </tag>
            
            <tag> GreedyAlgorithm </tag>
            
            <tag> ACM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 1328 3190 GreedyAlgorithm PriorityQueue]]></title>
      <url>https://kaikuxy.github.io/2017/04/03/poj-1328-3190/</url>
      <content type="html"><![CDATA[<p>微软题目没思路。。。。再推推吧。。。</p>
<h3 id="POJ-1328"><a href="#POJ-1328" class="headerlink" title="POJ 1328"></a>POJ 1328</h3><p>二维的区间覆盖，雷达固定在x轴上，问最少雷达数观测到所有小岛</p>
<p>最开始想着直接按照x轴或者y轴排序贪心，但是发现并不能，很容易就能找到反例，单单按照一个轴的方向排序并不能满足最优性。</p>
<p>考虑把一个点转化为一个区间，这个区间代表需要覆盖到这个点雷达可放置区间</p>
<p>其实和2376差不多，类似这种某个东西覆盖一些点的题目都是把数据转化为轴上可行的区间再操作。</p>
<p>转化为区间之后，将区间按l第一关键字从小到大，r第二关键字从大到小排序，每次判断当前区间和前一个区间是否有重叠。如果有重叠，就把当前区间更新为重叠部分。如果当前区间和前一个区间没有重叠，ans+1。</p>
<pre><code class="C++">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#define Maxn 1000
using namespace std;

struct Interval {
    double x, y;
}inter[Maxn + 10];

int n, d, ans, tot, cnt;

bool cmp(Interval, Interval);

int main() {
    //freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin);
    //freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);
    while (scanf(&quot;%d%d&quot;, &amp;n, &amp;d), !(n == 0 &amp;&amp; d == 0)) {
        cnt = 0;
        ans = 0;
        for (int i = 1;i &lt;= n;++ i) {
            int tempx, tempy;
            scanf(&quot;%d%d&quot;, &amp;tempx, &amp;tempy);
            if (tempy &gt; d)
                ans = -1;
            if (tempy &gt;= 0) {
                double temp = sqrt(d * d * 1.0 - tempy * tempy * 1.0);
                inter[++ cnt].x = tempx - temp;
                inter[cnt].y = tempx + temp;
            }
        }
        if (ans == -1) {
            printf(&quot;Case %d: %d\n&quot;, ++ tot, ans);
            continue;
        }
        double nowx, nowy;
        sort(inter + 1, inter + 1 + cnt, cmp);
        for (int i = 1;i &lt;= cnt;++ i) {
            if (ans == 0 || inter[i].x &gt; inter[i - 1].y)
                ++ ans;
            else {
                inter[i].x = max(inter[i].x, inter[i - 1].x);
                inter[i].y = min(inter[i].y, inter[i - 1].y);
            }
        }
        /*for (int i = 1;i &lt;= cnt;++ i)
            printf (&quot;\n%.4lf %.4lf&quot;, inter[i].x, inter[i].y);*/
        printf(&quot;Case %d: %d\n&quot;, ++ tot, ans);
    }
    //fclose(stdin);
    //fclose(stdout);
    return 0;
}

bool cmp(Interval a, Interval b) {
    if (a.x != b.x)
        return a.x &lt; b.x;
    return a.y &gt; b.y;
}
</code></pre>
<h3 id="POJ-3190"><a href="#POJ-3190" class="headerlink" title="POJ 3190"></a>POJ 3190</h3><p>一如既往的cow风</p>
<p>n个牛要在一个位置上独自榨奶时间L到R，问至少需要多少榨奶位以及每个牛在哪个榨奶位。</p>
<p>先按照起始时间从小到大排序。再维护一个小根堆（或者说优先队列）保存当前建立的榨奶位，该榨奶位当前已被占用到lasttime作为关键字。每次对于当前牛，如果优先队列中top元素的lasttime小于当前牛的起始时间，那么当前牛可以直接被分配到这个榨奶位，再把lastime更新为当前牛的结束时间；如果top元素的lastime都大于当前牛的起始时间，那么需要新建一个榨奶位。每次维护优先队列的同时记录当前牛被分配到的榨奶位序号。</p>
<pre><code class="C++">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;functional&gt;
#include &lt;queue&gt;
#define Maxn 50000
using namespace std;
2zsw
struct Interval {
    int l, r, num;
}inter[Maxn + 10];

struct Stall {
    friend bool operator &lt; (Stall x, Stall y) {
        return x.last &gt; y.last;
    }
    int num, last;
};

int n, ans;
int stall[Maxn + 10];

bool cmp(Interval, Interval);

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1;i &lt;= n;++ i) {
        scanf(&quot;%d%d&quot;, &amp;inter[i].l, &amp;inter[i].r);
        inter[i].num = i;
    }
    sort(inter + 1, inter + 1 + n, cmp);
    /*for (int i = 1;i &lt;= n;++ i)
        printf(&quot;%d %d\n&quot;, inter[i].l, inter[i].r);*/
    priority_queue&lt;Stall&gt; que;
    for (int i = 1;i &lt;= n;++ i) {
        if (ans == 0) {
            stall[inter[i].num] = ++ ans;
            Stall temp = {ans, inter[i].r};
            que.push(temp);
            //printf(&quot;Inter %d go to new stall %d\n&quot;, inter[i].num, ans);
            //printf(&quot;top stall last:%d\n&quot;, que.top().last);
            continue;
        }
        Stall temp = que.top();
        if (temp.last &lt; inter[i].l) {
            que.pop();
            temp.last = inter[i].r;
            stall[inter[i].num] = temp.num;
            que.push(temp);
            //printf(&quot;Inter %d go to existed stall %d\n&quot;, inter[i].num, temp.num);
        }
        else {
            Stall tt = {++ ans, inter[i].r};
            stall[inter[i].num] = ans;
            que.push(tt);
            //printf(&quot;Inter %d go to new stall %d\n&quot;, inter[i].num, ans);
        }
        //printf(&quot;top stall last:%d\n&quot;, que.top().last);
    }
    printf(&quot;%d\n&quot;, ans);
    for(int i = 1;i &lt;= n;++ i)
        printf(&quot;%d\n&quot;, stall[i]);
    return 0;
}

bool cmp(Interval a, Interval b) {
    return a.l &lt; b.l;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> POJ </category>
            
            <category> GreedyAlgorithm </category>
            
            <category> PriorityQueue </category>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> POJ </tag>
            
            <tag> GreedyAlgorithm </tag>
            
            <tag> PriorityQueue </tag>
            
            <tag> ACM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微软2017年预科生计划在线编程笔试_上]]></title>
      <url>https://kaikuxy.github.io/2017/04/01/%E5%BE%AE%E8%BD%AF2017%E5%B9%B4%E9%A2%84%E7%A7%91%E7%94%9F%E8%AE%A1%E5%88%92%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AF%95-%E4%B8%8A/</url>
      <content type="html"><![CDATA[<p>昨天晚上进行了微软2017预科生计划的在线编程笔试，然而之前并没有报名加上还有第二天的セリフ没做完于是没当时就做。<br>今天晚上仔细看了下，A了前两题，时间大概和现场的两个半小时差不多（自己还在听歌嗨）<br>后面两题明天再看吧。。。C题贼长，看都不想看</p>
<h3 id="ProblemA"><a href="#ProblemA" class="headerlink" title="ProblemA"></a>ProblemA</h3><p>题目链接在这里：<a href="http://hihocoder.com/problemset/problem/1489" target="_blank" rel="external">ProblemA</a></p>
<p>如果没有WA一次我根本没有意识到他每次抽中legendary item之后的起始概率是本次抽中开始的概率的1/2，而不是最开始的P的1/2，因为我把2上面那个I给无视掉了，而且这次又没有仔细看题。</p>
<p>题意大概就是你需要抽出来N张卡，起始的概率是P%，每次没有抽中会增加Q%的概率。在抽中一次后，概率会被重置为P/(2^i)(i是已经抽到的个数)。求抽中所有卡所需要次数的期望值。</p>
<ol>
<li>数据范围1 ≤ Q ≤ 100。那么每次一定可以在100次以内抽中卡。</li>
<li>每次抽卡可以当作独立事件计算期望最后加起来。</li>
<li>初始概率不断会被除以2向下取整，那么经过若干次之后初始概率一定会固定在0不动，最坏情况P初始等于100，这种情况下7次就会使初始概率固定在0。7次之后的卡就可以只需要计算一次了,数据范围里面N再大也没啥关系了。</li>
</ol>
<pre><code class="C++">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#define Maxn 100
using namespace std;
int P, Q, N;
int main() {
    scanf(&quot;%d%d%d&quot;, &amp;P, &amp;Q, &amp;N);
    int cnt;
    double ans = 0, pnow, tempp, tempans;
    while (N) {
        cnt = 0;
        pnow = P / 100.0, tempp = 1.0, tempans = 0.0;
        while (true) {
            tempans += (++ cnt) * tempp * pnow;
            if (pnow == 1.0)
                break;
            tempp = tempp * (1.0 - pnow);
            pnow += Q / 100.0;
            if (pnow &gt; 1.0)
                pnow = 1.0;
        }
        ans += tempans;
        -- N;
        if (P == 0)
            break;
        P = P / 2;
    }
    if (N)
        ans = ans + N * tempans;
    printf (&quot;%.2lf\n&quot;, ans);
    return 0;
}
</code></pre>
<p>因为没看清题浪费了好多时间。。。</p>
<h3 id="ProblemB"><a href="#ProblemB" class="headerlink" title="ProblemB"></a>ProblemB</h3><p>题目链接在这里：<a href="http://hihocoder.com/problemset/problem/1490" target="_blank" rel="external">ProblemB</a></p>
<p>一个n个点的树，现在不知道树的具体样子，只知道：</p>
<ol>
<li>哪些结点是叶子结点</li>
<li>每两个叶子结点之间的距离</li>
<li>每个结点的深度</li>
<li>每层从左到右结点的编号</li>
</ol>
<p>现在需要知道每个结点的父亲是谁</p>
<p>做法：</p>
<p>从最后一层开始处理，很显然的性质就是如果两个结点同父亲，那么他们两个的距离就是2，否则两个节点的距离大于2。</p>
<p>因为我们知道每层从左到右的结点分别是什么，那么对于每层结点从左到右，和前一个结点的距离为2的结点的父亲就是前一个结点的父亲；和前一个点的距离大于2，属于新的一个父亲，如此依次更新。</p>
<p>更新完这一层的结点之后，需要更新结点的距离。</p>
<p>题目只给了叶子结点的距离，每次更新完一层结点的父亲之后，该层两两结点的父亲之间的距离就是两个结点距离-2，而对于深度小于当前层的叶子结点，其与该层结点父亲的距离就是与此结点的距离-1。为什么这样不说了，画出来很显然。</p>
<p>一A</p>
<pre><code class="C++">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#define Maxn 100
using namespace std;

int n, m, k;
int num_of_depth[Maxn + 10];
int Deep[Maxn + 10];
int node[Maxn + 10][Maxn + 10];
int dis[Maxn + 10][Maxn + 10];
int parent[Maxn + 10];
int leave[Maxn + 10];
bool isleave[Maxn + 10];

void init();
void work(int);

int main() {
    init();
    for (int t = m;t &gt; 1;-- t)
        work(t);
    printf(&quot;%d&quot;, parent[1]);
    for (int i = 2;i &lt;= n;++ i)
        printf(&quot; %d&quot;, parent[i]);
    printf(&quot;\n&quot;);
    return 0;
}

void init() {
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
    for (int i = 1;i &lt;= m;++ i)
        scanf(&quot;%d&quot;, &amp;num_of_depth[i]);
    //printf(&quot;num_of_depth\n&quot;);
    for (int i = 1;i &lt;= m;++ i)
        for (int j = 1;j &lt;= num_of_depth[i];++ j)
        {
            scanf(&quot;%d&quot;, &amp;node[i][j]);
            Deep[node[i][j]] = i;
        }
    //printf(&quot;node\n&quot;);
    for (int i = 1;i &lt;= k;++ i) {
        int temp;
        scanf(&quot;%d&quot;, &amp;leave[i]);
        isleave[leave[i]] = true;
    }
    //printf(&quot;leave\n&quot;);
    for (int i = 1;i &lt;= k;++ i)
        for (int j = 1;j &lt;= k;++ j)
            scanf(&quot;%d&quot;, &amp;dis[leave[i]][leave[j]]);
}

void work(int depth) {
    int start = 0, pre = 0;
    for (int i = 1;i &lt;= num_of_depth[depth];++ i) {
        if (i == 1 || dis[node[depth][i]][node[depth][i - 1]] != 2) {
            //printf(&quot;%d != %d\n&quot;, node[depth][i], node[depth][i - 1]);
            ++ start;
            while (isleave[node[depth - 1][start]])
                ++ start;
            parent[node[depth][i]] = node[depth - 1][start];
            //printf(&quot;%d parent: %d\n&quot;, node[depth][i], node[depth - 1][start]);
        }
        if (dis[node[depth][i]][node[depth][i - 1]] == 2)
            parent[node[depth][i]] = parent[node[depth][i - 1]];
    }
    for (int i = 1;i &lt;= num_of_depth[depth];++ i)
        for (int j = 1;j &lt;= num_of_depth[depth];++ j)
        {
            dis[parent[node[depth][i]]][parent[node[depth][j]]] = dis[node[depth][i]][node[depth][j]] - 2;
            /*if (node[depth][i] &lt; node[depth][j])
                printf(&quot;update %d %d parent: %d %d %d\n&quot;, node[depth][i], node[depth][j], parent[node[depth][i]], parent[node[depth][j]], dis[parent[node[depth][i]]][parent[node[depth][j]]]);*/
        }
    for (int i = 1;i &lt;= k;++ i)
        if (Deep[leave[i]] &lt; depth)
            for (int j = 1;j &lt;= num_of_depth[depth];++ j) {
                dis[leave[i]][parent[node[depth][j]]] = dis[leave[i]][node[depth][j]] - 1;
                dis[parent[node[depth][j]]][leave[i]] = dis[leave[i]][parent[node[depth][j]]];
            }
}
</code></pre>
<p>昨天晚上结束AB题都过了的大概150多人吧，C题过了的只有7个人。。。D题过了的只有6个。。。现在也只有11和11人过了。。。大概是神们都不屑于做</p>
<p>题外话，在网上看这个比赛往届消息的时候，发现微软远程Skype面试中需要在共享白板上直接写代码。</p>
<p>在面试官眼皮底下写啊！！！感觉自己很慌，压力极大。还有很长路要走，哎。</p>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[non-recursive traversal of binary tree]]></title>
      <url>https://kaikuxy.github.io/2017/03/28/non-recursive-traversal-of-binary-tree/</url>
      <content type="html"><![CDATA[<p>以前经常说：</p>
<p>系统栈爆了怎么办？</p>
<p>手写啊！！</p>
<p>然而并没有写过一次</p>
<p>这次数据结构课介绍了非递归的二叉树遍历算法，后序还没讲，先写了再说</p>
<p>先序遍历：</p>
<p>1.我的直观想法是先把右子树压进去，再把左子树压进去</p>
<p>2.然而书上给的做法有点不一样，是先压左子树压到底，弹出的时候把当前的右子树给压进去。事实上在先序遍历上来说这两种做法没什么区别，我的想法相当于在压左子树之前就直接先把右子树压进去了</p>
<p>中序遍历：</p>
<p>中序遍历的时候我的做法不是那么管用了，因为先序遍历根节点最先访问，而中序需要左子树弹回来才能访问根节点，所以必须得用类似上面做法2的一样的思路</p>
<p>后序遍历：</p>
<p>可以和先序遍历一样一次性把右左子树压进去，在访问根节点前判一下上一个访问的是不是根节点的左右儿子，也就是说是不是从访问完左右儿子之后弹回来的，或者根本没有左右儿子，满足两种情况之一才能将这个点弹出来并访问，同时更新pre为这个根节点</p>
<pre><code class="C++">void preOrder1(BiTree root) {
    stack &lt;BiTree&gt; s;
    BiTree p = root;
    while (p != NULL || !s.empty()) {
        while (p != NULL) {
            visit(p);
            s.push(p);    //prepare the traversal for the p&#39;s right child
            p = p -&gt; lchild;
        }
        if (!s.empty()) {
            p = s.top();    //get the node
            s.pop();
            p = p -&gt; rchild;    // turn to right child
        }
    }
}

void preOrder2(BiTree root) {
    stack &lt;BiTree&gt; s;
    BiTree p = root;
    while (!s.empty()) {
        vist(p = s.top());
        s.pop();
        if (p -&gt; rchild != NULL)
            s.push(p -&gt; rchild);
        if (p -&gt; lchild != NULL)
            s.push(p -&gt; lchild);
    }
}

void inOrder(BiTree root) {
    stack &lt;BiTree&gt; s;
    BiTree p = root;
    while (p != NULL || !s.empty()) {
        while (p != NULL) {
            s.push(p);    //prepare the traversal for the p&#39;s right child
            p = p -&gt; lchild;
        }
        if (!s.empty()) {
            visit(p = s.top());
            s.pop();
            push(s.rchild);
        }
    }
}

void postOrder(BiTree root) {
    stack &lt;BiTree&gt; s;
    BiTree p = root, pre = NULL;
    s.push(root);
    while (!s.empty()) {
        p = s.top();
        if ((p -&gt; lchild == NULL &amp;&amp; p -&gt; rchild == NULL) || (pre != NULL &amp;&amp; (pre == p -&gt; lchild || pre == p -&gt; rchild))) {     // come from child node
            visit(p);
            s.pop();
            pre = p;
        }
        else {
            if (p -&gt; rchild != NULL)
                s.push(p -&gt; rchild);
                if (p -&gt; lchild != NULL)
                    s.push(p -&gt; lchild);
        }
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[今天的Coursera测验做了三次才对这说明对Precision和Recall的理解有问题]]></title>
      <url>https://kaikuxy.github.io/2017/03/26/%E4%BB%8A%E5%A4%A9%E7%9A%84Coursera%E6%B5%8B%E9%AA%8C%E5%81%9A%E4%BA%86%E4%B8%89%E6%AC%A1%E6%89%8D%E5%AF%B9%E8%BF%99%E8%AF%B4%E6%98%8E%E5%AF%B9Precision%E5%92%8CRecall%E7%9A%84%E7%90%86%E8%A7%A3%E6%9C%89%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>知道Precision和Recall是什么但是还是有点在区别的时候犯迷糊，加上这次的题目出的感觉有点模糊，有些描述有点模棱两可</p>
<p>用通俗点的话来描述Precision和Recall分别就是</p>
<p>Precision：判断的准确率，在你判断为真的数据中事实上就是真的比例</p>
<p>Recall：在所有为真的数据中你判断为真的比例,也就是你没有漏判的程度</p>
<p><strong>!!一般的，我们将数据中出现少的那一种情况定义为真!!</strong></p>
<p>也就是，假设我们使用了logistic regression，最后给的h(x)在[0, 1]，如果我们想更准确判断，那么会有更高的Precision，以及更低的Recall；而如果我们不想漏过某个为真的数据，那么会有更高的Recall，以及更低的Precision</p>
<p>因为我们取得的数据有可能会是skewed class，比如数据中99%的患者没有得癌症，而只有1%的患者得了癌症，这种情况下，单单使用accuracy来衡量某个学习算法是不好的，举一个反例就是我们可以让算法直接判断所有患者都没有得癌症，这样得到的accuracy达到了99%，但是这并不是我们想要的</p>
<p>因此我们使用F1score = (2 <em> Precision </em> Recall) / (Precision + Recall)来衡量</p>
<p>用上面那个例子，99%的患者没有得癌症</p>
<p>1&gt;   假设我们判断所有的患者都得了癌症，我们得到了100%的Recall因为我们没有漏过任何一个病例，另一方面，我们得到了1%的Precision，因为实际上只有1%的患者得了癌症，而总准确率为0.01</p>
<p>2&gt;   假设我们判断所有的患者都没有得癌症，我们得到了0%的Recall因为我们漏掉了所有病例，另一方面，我们得到了0%的Precision因为我们所有判断得癌症的准确率是0，而我们得总准确率却有0.99</p>
<p>我们在用F1score衡量的时候，会希望F1score越大越好。在最理想情况下，我们准确且未漏判所有得了癌症的患者，这个时候，我们的F1score为</p>
<p>F1score = (2 <em> 1 </em> 1) / (1 + 1) = 1</p>
<p>这么理了一下感觉清晰些了</p>
<p>PS：什么时候把前面学的也理一下呢</p>
]]></content>
      
        <categories>
            
            <category> MachineLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MachineLearning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[趣味と仕事、どちらが大事]]></title>
      <url>https://kaikuxy.github.io/2017/03/26/Debate-Interest-and-Work/</url>
      <content type="html"><![CDATA[<p>　生活するために、仕事をしなければならない。仕事がないと、生きるための金もない、生活するのも問題の状況で、趣味を発展する余裕はあるのか。そもそも、仕事ということは、生計を立てるために、自分の生活をより楽しくより幸福になるために、必要なことです。趣味を見つけて、愛し、発展し続けることもその「より楽しく、より幸福になる」にあるのです。つまり、仕事が趣味の存在を支持するのです。</p>
<p>　WIKIで、趣味という単語はこのように説明するのです：</p>
<pre><code>趣味は、以下の二つの意味を持つ。
１．人間が自由時間（生理的必要時間と労働時間を除いた時間、余暇）に、好んで習慣的に繰り返しおこなう行為、事柄やその対象のこと。
２．物の持つ味わい・おもむきを指し、それを鑑賞しうる能力（美しいものや面白いものについての好みや嗜好）のこと。
</code></pre><p>　つまり、趣味は、仕事が終わった後、時間があったらできるのです。このような説明方も、仕事の方が大事だということを私たちに教えてくれたのです。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 2376 GreedyAlgorithm]]></title>
      <url>https://kaikuxy.github.io/2017/03/26/poj-2376/</url>
      <content type="html"><![CDATA[<p>贪心</p>
<p>l为第一关键字，r为第二关键字排序</p>
<p>每次选择当前l合法的有最远的r的区间</p>
<p>很多，很多注意事项</p>
<ol>
<li>区间不需要覆盖，…, r] [r+1, … 就合法</li>
<li>数据给的最远r可能大于T</li>
<li>数据给的最近l可能大于1</li>
<li>可能存在[1, 1] [1, 2] [1, 3] …. 这种情况，所以不要直接先把第一个区间取了，特判到死</li>
</ol>
<p>第一版代码又臭又长，我也不知道为什么过这么久没写代码会用while里面还套while还重复判相同条件这种东西，还多出很多毫无意义的变量</p>
<p>教训：</p>
<ol>
<li>特判会让自己的代码又臭又长，还难读，能用一个循环绝不在开头加特判处理初始情况，纯属没事找事做</li>
<li>不要开毫无意义的变量，想想怎么样可以简单表达</li>
<li>读题读题读题读题读题读题读题</li>
<li>找反例不是让自己加特判的，是让自己的代码更普遍化，通用更多数据</li>
</ol>
<pre><code class="C++">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#define Maxn 25000
using namespace std;
struct interval {
    int start, end;
}inter[Maxn + 10];
int N, T, ans;
bool cmp(interval, interval);
int main() {
    scanf(&quot;%d%d&quot;, &amp;N, &amp;T);
    for (int i = 0;i &lt; N;++ i)
        scanf(&quot;%d%d&quot;, &amp;inter[i].start, &amp;inter[i].end);
    sort(inter, inter + N, cmp);
    /*for (int i = 0;i &lt; N;++ i)
        printf(&quot;%d %d\n&quot;, inter[i].start, inter[i].end);*/
    int iter = 0, start, end = 0;
    while (end &lt; T) {
        start = end + 1;
        for (int i = iter;i &lt; N;++ i)
            if (inter[i].start &lt;= start)
                end = max(end, inter[i].end);
            else {
                iter = i;
                break;
            }
        if (start &gt; end) {
            ans = -1;
            break;
        }
        ++ ans;
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
bool cmp(interval x, interval y) {
    if(x.start != y.start)
        return x.start &lt; y.start;
    else
        return x.end &lt; y.end;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> POJ </category>
            
            <category> GreedyAlgorithm </category>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> POJ </tag>
            
            <tag> GreedyAlgorithm </tag>
            
            <tag> ACM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 2718 GreedyAlgorithm STL]]></title>
      <url>https://kaikuxy.github.io/2017/03/25/poj-2718/</url>
      <content type="html"><![CDATA[<p>做了一上午的2718，差点爆炸</p>
<p>做法一：<br>用到了STL中的next_permutation产生所有的全排列<br>要使生成的两个数差最小，两个数的位数差肯定小于等于1，产生一个排列之后在中间分开就可以</p>
<p>什么时候详细写一下STL里面产生全排列的写法</p>
<pre><code class="C++">/*
    next_permutation
*/
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;time.h&gt;
using namespace std;

int t, cnt, ans;
char arr[10 + 1];
char input[20];

int make(int, int);

int main() {
    //clock_t start, end;
    //freopen(&quot;output.txt&quot;, &quot;r&quot;, stdin);
    //freopen(&quot;out1.txt&quot;, &quot;w&quot;, stdout);
    scanf(&quot;%d&quot;, &amp;t);
    getchar();
    while (t --) {
        cnt = 0;
        gets(input);
        for (int i = 0;i &lt; strlen(input);++ i)
            if (input[i] != &#39; &#39;)
                arr[cnt ++] = input[i];
        //printf(&quot;cnt: %d\n&quot;, cnt);
        //start = clock();
        sort(arr, arr + cnt);
        //for (int i = 0;i &lt; cnt;++ i)
            //printf(&quot;%d&quot;, arr[i]);
        ans = -1;
        do {
                if (arr[0] == &#39;0&#39; || arr[cnt / 2] == &#39;0&#39; &amp;&amp; cnt &gt; 2)
                    continue;
                int temp = abs(make(0, cnt / 2 - 1) - make(cnt / 2, cnt - 1));
                ans = (ans == -1 || ans &gt; temp) ? temp : ans;
        } while(next_permutation(arr, arr + cnt));
        printf(&quot;%d\n&quot;, ans);
        //end = clock();
        //printf(&quot;time:%f\n&quot;, (double)(end - start) / CLOCKS_PER_SEC);
    }
    //fclose(stdin);
    //fclose(stdout);
    return 0;
}

int make(int a, int b) {
    int temp = 0;
    for(int i = a;i &lt;= b;++ i)
        temp = temp * 10 + arr[i] - &#39;0&#39;;
    return temp;
}
</code></pre>
<p>做法二：<br>分情况<br>如果是偶数的话，枚举所有两个相差最近的数当作两个生成的数的最高位，之后大数不断取剩下的数中最小的数当作下一位，小数不断取剩下的数中最大的数当作下一位，对于每个枚举更新下ans<br>如果是奇数的话，就不需要枚举最高位了，因为大的那个数最高位一定得取最小的数字，剩下和偶数做法一样不断取最小的数最大的数然后更新ans<br>然后需要注意在偶数枚举最高位的时候，不能考虑数字0，其他情况下先不考虑0到最后计算差值的时候如果0出现在第一位就和后面数字换一下位置就可以<br>我也不知道为什么贪心会WA那么多次，大概是我太菜了，把所有数据全部生成出来对比才发现问题，哎.什么时候还再回忆一下对拍咋写</p>
<p>代码又臭又长</p>
<pre><code class="C++">/*
    greedy
*/
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;time.h&gt;
using namespace std;

int t, cnt, ans;
char arr[10];
char input[20], num1[10], num2[10];
bool use[10];
int cnt1, cnt2;

int make(char*, int, int);

int main() {
    //clock_t start, end;
    //freopen(&quot;output.txt&quot;, &quot;r&quot;, stdin);
    //freopen(&quot;out2.txt&quot;, &quot;w&quot;, stdout);
    scanf(&quot;%d&quot;, &amp;t);
    getchar();
    while (t --) {
        ans = -1;
        cnt1 = cnt2 = 0;
        cnt = 0;
        gets(input);
        for (int i = 0;i &lt; strlen(input);++ i)
            if (input[i] != &#39; &#39;)
                arr[cnt ++] = input[i];
        //printf(&quot;cnt: %d\n&quot;, cnt);
        //start = clock();
        sort(arr, arr + cnt);
        //for (int i = 0;i &lt; cnt;++ i)
            //printf(&quot;%d&quot;, arr[i]);
        /*
        do {
                if (arr[0] == &#39;0&#39; || arr[cnt / 2] == &#39;0&#39; &amp;&amp; cnt &gt; 2)
                    continue;
                int temp = abs(make(0, cnt / 2 - 1) - make(cnt / 2, cnt - 1));
                ans = (ans == -1 || ans &gt; temp) ? temp : ans;
        } while(next_permutation(arr, arr + cnt));*/
            if(cnt == 2) {
                printf(&quot;%d\n&quot;, abs(arr[1] - arr[0]));
                continue ;
            }

            int Min = 10000;

            if(cnt % 2) {
                int temp = (cnt - ((cnt % 2) ? 0 : 2)) / 2 + 1;
                for (int i = 0;i &lt; cnt &amp;&amp; temp;++ i) {
                    num1[cnt1 ++] = arr[i];
                    -- temp;
                }
                temp = (cnt - ((cnt % 2) ? 0 : 2)) / 2;
                for (int i = cnt - 1;i &gt;= 0 &amp;&amp; temp;-- i) {
                    num2[cnt2 ++] = arr[i];
                    -- temp;
                }
                /*printf(&quot;Bigger: &quot;);
                for (int j = 0;j &lt; cnt1;++ j)
                    printf(&quot;%c &quot;, num1[j]);
                printf(&quot;\n&quot;);
                printf(&quot;Smaller: &quot;);
                for (int j = 0;j &lt; cnt2;++ j)
                    printf(&quot;%c &quot;, num2[j]);
                printf(&quot;\n&quot;);*/
                temp = abs(make(num1, 0, cnt1 - 1) - make(num2, 0, cnt2 - 1));
                ans = temp;
            }
            else {
                for (int i = 0;i &lt; cnt - 1;++ i)
                    if (arr[i] != &#39;0&#39;)
                        Min = min(Min, arr[i + 1] - arr[i]);
                for (int i = 0;i &lt; cnt - 1;++ i)
                    if (arr[i] != &#39;0&#39;) {
                        if (Min == arr[i + 1] - arr[i])
                        {
                            cnt1 = cnt2 = 0;
                            int temp;
                            memset(use, 0, sizeof(use));
                            use[i + 1] = use[i] = true;
                            num1[cnt1 ++] = arr[i + 1]; // bigger
                            num2[cnt2 ++] = arr[i]; // smaller

                            //printf(&quot;cnt1: %d    cnt2: %d\n&quot;, cnt1, cnt2);

                            temp = (cnt - ((cnt % 2) ? 0 : 2)) / 2;
                            for (int j = 0;j &lt; cnt &amp;&amp; temp;++ j)
                                if (!use[j]) {
                                    num1[cnt1 ++] = arr[j];
                                    -- temp;
                                }
                            temp = (cnt - ((cnt % 2) ? 0 : 2)) / 2;
                            for (int j = cnt - 1;j &gt;= 0 &amp;&amp; temp;-- j)
                                if (!use[j]) {
                                    num2[cnt2 ++] = arr[j];
                                -- temp;
                                }
                            /*for (int j = 0;j &lt; cnt1;++ j)
                            printf(&quot;%c &quot;, num1[j]);
                            printf(&quot;\n&quot;);
                            for (int j = 0;j &lt; cnt2;++ j)
                            printf(&quot;%c &quot;, num2[j]);
                            printf(&quot;\n&quot;);*/
                            temp = abs(make(num1, 0, cnt1 - 1) - make(num2, 0, cnt2 - 1));
                            //printf (&quot;%d\n&quot;, temp);
                            ans = (ans == -1 || ans &gt; temp) ? temp : ans;
                        }
                    }
            }
        printf(&quot;%d\n&quot;, ans);
        //end = clock();
        //printf(&quot;time:%f\n&quot;, (double)(end - start) / CLOCKS_PER_SEC);
    }
    //fclose(stdin);
    //fclose(stdout);
    return 0;
}

int make(char* s ,int a, int b) {
    int temp = 0;
    //printf(&quot;%c %c\n&quot;, *(s + a), *(s + a + 1));
    if(b - a &gt; 0 &amp;&amp; *(s + a) == &#39;0&#39;) {
        char tempc = *(s + a);
        *(s + a) = *(s + a + 1);
        *(s + a + 1) = tempc;
    }
    for(int i = a;i &lt;= b;++ i)
        temp = temp * 10 + *(s + i) - &#39;0&#39;;
    return temp;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> POJ </category>
            
            <category> GreedyAlgorithm </category>
            
            <category> ACM </category>
            
            <category> STL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> POJ </tag>
            
            <tag> GreedyAlgorithm </tag>
            
            <tag> ACM </tag>
            
            <tag> STL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Haru!!]]></title>
      <url>https://kaikuxy.github.io/2017/03/23/Haru/</url>
      <content type="html"><![CDATA[<p>HARU!!!!!!</p>
<p><img src="/images/haru.gif" alt="这里写图片描述"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 1979 3669 BFS DFS]]></title>
      <url>https://kaikuxy.github.io/2017/03/23/poj-1979-3669/</url>
      <content type="html"><![CDATA[<p>一道DFS一道BFS</p>
<p>1979:</p>
<p>DFS无脑扫就可以了</p>
<pre><code class="C++">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#define MaxW 20
using namespace std;

int W, H, ans;
char input;
bool sign[MaxW + 10][MaxW + 10];
pair &lt;int, int&gt; start;
bool tra[MaxW + 10][MaxW + 10];

void Tra(int, int);

int main() {
    while (scanf(&quot;%d%d&quot;, &amp;W, &amp;H), !(W == 0 &amp;&amp; H == 0)) {
        ans = 0;
        getchar();
        memset(tra, 0, sizeof(tra));
        for (int i = 1;i &lt;= H;++ i) {
            for (int j = 1;j &lt;= W;++ j) {
                scanf(&quot;%c&quot;, &amp;input);
                if(input == &#39;.&#39;)    sign[i][j] = true;
                else if(input == &#39;#&#39;)    sign[i][j] = false;
                else {
                    sign[i][j] = true;
                    start = make_pair(i, j);
                }
            }
            getchar();
        }
        Tra (start.first, start.second);
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}

void Tra(int x, int y) {
    //printf (&quot;%d %d\n&quot;, x, y);
    ++ ans;
    tra[x][y] = true;
    if(x + 1 &lt;= H &amp;&amp; sign[x + 1][y] &amp;&amp; !tra[x + 1][y])
        Tra(x + 1, y);
    if(x - 1 &gt;= 1 &amp;&amp; sign[x - 1][y] &amp;&amp; !tra[x - 1][y])
        Tra(x - 1, y);
    if(y + 1 &lt;= W &amp;&amp; sign[x][y + 1] &amp;&amp; !tra[x][y + 1])
        Tra(x, y + 1);
    if(y - 1 &gt;= 1 &amp;&amp; sign[x][y - 1] &amp;&amp; !tra[x][y - 1])
        Tra(x, y - 1);
}
</code></pre>
<p>问题就出在3669上</p>
<p>做法没什么好说的，预处理每个点最早被流星破坏的时间入队前判断一下当前时间是否在最早被流星破坏的时间前就可以了<br>然后注意题目中给的数据范围是流星坠落的数据范围，并不是整块地的<br>所以要再开大一点<br>然后T了3，4次<br>最后终于发现了问题<br>在每次入队的时候先把visit给标记了，要不然会多出很多很多相同的冗余元素在队里面，因为bfs和dfs不一样，bfs会一层中一次性入很多元素</p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#define INF 3000
#define Maxx 300
using namespace std;

struct elem {
    int a, b, time;
};

int m, x, y, t, ans;
int destr[Maxx + 10][Maxx + 10];
bool tra[Maxx + 10][Maxx + 10];
int dx[5] = {1, -1, 0, 0, 0};
int dy[5] = {0, 0, 1, -1, 0};

int main() {
    ans = -1;
    scanf(&quot;%d&quot;, &amp;m);
    for (int i = 0;i &lt; Maxx + 10;++ i)
        for (int j = 0;j &lt; Maxx + 10;++ j)
            destr[i][j] = INF;
    for (int i = 1;i &lt;= m;++ i) {
        scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;t);
        for (int j = 0;j &lt; 5;++ j)
        {
            int xx = x + dx[j], yy = y + dy[j];
            if(xx &gt;= 0 &amp;&amp; yy &gt;= 0)
                destr[xx][yy] = min(destr[xx][yy], t);
        }
    }
    if (destr[0][0] == 0) {
        printf(&quot;-1\n&quot;);
        return 0;
    }
    if (destr[0][0] == INF) {
        printf(&quot;0\n&quot;);
        return 0;
    }
    queue &lt;elem&gt; timeline;
    elem start;    start.a = 0, start.b = 0, start.time = 0;
    timeline.push(start);
    while(!timeline.empty()) {
        elem temp = timeline.front();
        timeline.pop();
        //tra[temp.a][temp.b] = true;

        for(int i = 0;i &lt; 4;++ i) {
            int xx = temp.a + dx[i], yy = temp.b + dy[i], tt = temp.time + 1;
            if(xx &gt;= 0 &amp;&amp; yy &gt;= 0 &amp;&amp; destr[xx][yy] &gt; tt &amp;&amp; !tra[xx][yy]) {
                tra[xx][yy] = true;
                if (destr[xx][yy] == INF) {
                    printf(&quot;%d\n&quot;, tt);
                    return 0;
                }
                start.a = xx;
                start.b = yy;
                start.time = tt;
                timeline.push(start);
            }
        }
    }
    printf(&quot;-1\n&quot;);
    return 0;
}
</code></pre>]]></content>
      
        <categories>
            
            <category> POJ </category>
            
            <category> BFS </category>
            
            <category> DFS </category>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> POJ </tag>
            
            <tag> ACM </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[bbctest]]></title>
      <url>https://kaikuxy.github.io/2017/03/21/bbctest/</url>
      <content type="html"><![CDATA[<p><iframe width="400" height="500" frameborder="0" src="http://www.bbc.co.uk/programmes/p04xfxhz/player"></iframe> </p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[math]]></title>
      <url>https://kaikuxy.github.io/2017/03/21/math/</url>
      <content type="html"><![CDATA[<p>simple line $a = b + c$</p>
<p>$\frac{\partial u}{\partial t} = h^2 \left( \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} + \frac{\partial^2 u}{\partial z^2}\right)$</p>
<p>$$<br>\frac{\partial u}{\partial t} = h^2 \left( \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} + \frac{\partial^2 u}{\partial z^2}\right)<br>$$</p>
<p>$$<br>h(n) = h(0) * h(n - 1) + h(1) + b + c + d + e + f + h(n - 3)<br>$$</p>
<p>$$<br>h(n) = h(0) <em> h(n - 1) + h(1) + b + c + d + e + f + h(n - 3) </em> h(n - 4)<br>$$</p>
<p>h(n) = h(0) <em> h(n - 1) + h(1) + b + c + d + e + f + h(n - 3) </em> h(n - 4)</p>
<p>h(n) = h(0) <em> h(n - 1) + h(1) </em> h(n - 2) + … + h(n - 1) * h(0)</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Catalan数]]></title>
      <url>https://kaikuxy.github.io/2017/03/20/Catalan%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>上个星期数据结构出了一道题目，给定4个数1,2,3,4入栈序列，问可能的出栈序列，以及出栈序列有哪些。<br>因为只要求4个元素的答案，所以直接手写判断了，判断方法按照栈的性质来，对于一个待判断的序列，需要满足对于所有元素，在这个元素之后出现的所有比他先入栈的（在这里给出了就是元素1234所以就是比他小的）应满足后入先出的规则（在这里就是满足递减）。这样就很容易判断出哪些是合法的出栈序列了。<br>我们知道了对于每个序列如何判断是否合法，那么对于一个n个元素的序列，他的所有合法的出栈序列有多少个呢？</p>
<p>先来看另一个问题：</p>
<p>对于n对括号()，有多少种匹配方式？( n = 2的情况：()() 或者 (())两种 )</p>
<p>很容易想到可以从n-1对括号推过来<br>（….）….<br>括号内以及括号外是已经匹配完成的n-1对括号，括号内括号对数可以为0,1,2,…..,n-1<br>得出递推式</p>
<blockquote>
<p><img src="http://latex.codecogs.com/gif.latex?h(n) = \sum_{i=0}^{n-1}h(i)*h(n-1-i)"><br>h(n)为n对括号匹配方式</p>
</blockquote>
<p>数列h(n)就是Catalan数列，前几项是1,1,2,5,14,42,132,429,1430,4862,16796<br>上面是递推式，直接求h(n)的话就是：</p>
<blockquote>
<p><img src="http://latex.codecogs.com/gif.latex?h(n)=\frac{1}{n+1}\binom{2n}{n}"></p>
</blockquote>
<p>我们再来看刚刚的n元素出栈序列种数问题<br>每一个合法的出栈序列都对应一个合法的入栈序列，那么可以把入栈当作左括号，出栈当作右括号。不管入栈出栈元素是哪一个，某一个入栈出栈序列合法的条件是每次出栈前面必定一一对应着一个入栈的元素，可以发现这和n对括号匹配的问题是一样的。</p>
<p>答案就很明显了，n元素出栈序列种数为<img src="http://latex.codecogs.com/gif.latex?h(n)"></p>
<p>再来看一些关于Catalan数的问题：</p>
<p><strong>1. <img src="http://latex.codecogs.com/gif.latex?P=A1*A2*\cdots*An">，问有多少种计算先后顺序方案</strong></p>
<p>运用结合律形成各种计算先后顺序，相当于加上若干个括号，同样运用递推的思想得出</p>
<blockquote>
<p><img src="http://latex.codecogs.com/gif.latex?f(n) = \sum_{i=1}^{n-1}f(i)*f(n-i)"><br><img src="http://latex.codecogs.com/gif.latex?f(n)=h(n-1)"></p>
</blockquote>
<hr>
<p><strong>2.n个结点的二叉树，有多少种形态</strong></p>
<p>相当于在当前根下左子树种数*右子树种数，直接得出</p>
<blockquote>
<p><img src="http://latex.codecogs.com/gif.latex?f(n) = \sum_{i=0}^{n-1}f(i)*f(n-1-i)"></p>
</blockquote>
<hr>
<p><strong>3.在圆上选择<img src="http://latex.codecogs.com/gif.latex?2*n"> 个点，将这些点成对连起来形成n条线段，求满足这n条线段不想交的方案数</strong></p>
<p>任意选择一个点开始，在剩下n-1个点中选取的点应满足由这两个点形成的线段两边都有偶数个。假设如果一边有奇数个，那么这边一定有一个点被剩下来使得它只有和其他线段相交才能到另一边与其他点连接成一条线段。<br>记<img src="http://latex.codecogs.com/gif.latex?f(n)"> 为选择n个点满足题目要求的方案数<br>根据上面所说可以得出递推式</p>
<blockquote>
<p><img src="http://latex.codecogs.com/gif.latex?f(n) = \sum_{i=0}^{\frac{n-2}{2}}f(i*2)*f(n-2-i*2)"></p>
</blockquote>
<p>发现<img src="http://latex.codecogs.com/gif.latex?f(n)=h(\frac{n}{2})"></p>
<hr>
<p><strong>4. n个点的凸多边形，划分成一个个三角形区域的方案数</strong></p>
<p>显然最后划分成的所有三角形中存在一个三角形它的两个点是相邻的。不妨假设我们对于当前凸多边形选取某两个相邻的点当作三角形的期中两个点，我们需要寻找剩下一个点来形成一个三角形<br>很容易发现，当我们将某个点设为这个三角形剩下的一个点的时候，这个凸多边形被我们划分成了三块，一块是我们划分出的三角形，另两块为分布在该三角形两边的凸多边形，那么方案数就是</p>
<blockquote>
<p>左边凸多边形划分三角形的方案数*右边凸多边形的方案数</p>
</blockquote>
<p> 记<img src="http://latex.codecogs.com/gif.latex?f(n)"> 为n个点的凸多边形划分三角形的方案数，我们记</p>
<blockquote>
<p><img src="http://latex.codecogs.com/gif.latex?f(2)=1,f(3)=1"><br>（当<img src="http://latex.codecogs.com/gif.latex?n=2"> 时，意味着在上一层划分时三个点是相邻的）</p>
</blockquote>
<p>得出递推式</p>
<blockquote>
<p><img src="http://latex.codecogs.com/gif.latex?f(n)=f(2)*f(n-1)+f(3)*f(n-2)+\cdots+f(n-1)*f(2)"></p>
</blockquote>
<p>发现<img src="http://latex.codecogs.com/gif.latex?f(n)=h(n-2)"></p>
<hr>
<p><strong>5. wiki上的一个：在一个n*n的格子中，从左下出发到右上，每次只能向右或者向上走一个格子的一条边，不能跨过左下到右上的对角线，求行动方案数</strong></p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f4/Catalan_number_4x4_grid_example.svg/450px-Catalan_number_4x4_grid_example.svg.png" alt="这里写图片描述"></p>
<p>我们知道走到右上行动次数一定是n次向右与n次向上，不能跨过对角线的意思就是行动当前向上行动的次数不能大于向右行动的次数。<br>其实就和括号配对的问题是一样的了，方案数就是<img src="http://latex.codecogs.com/gif.latex?h(n)"></p>
<hr>
<p><strong>6. 还有一个贴切生活的问题：<img src="http://latex.codecogs.com/gif.latex?2*n"> 个人排队进入剧院，入场费5元，n个人只有5元钞票，剩下n个人只有10元钞票，收银员当前没有供找零的钱，问可行的排队方案（一点都不贴切生活）</strong></p>
<p>和括号配对也是一样，只有5元钞票的人视为入栈，只有10元钞票的人必须找零5元，相当于出栈，那么方案数就是<img src="http://latex.codecogs.com/gif.latex?h(n)"></p>
<hr>
<p><strong>7. 2*n个人排队，排成两排，每排从左到右从高到矮，第二排的人比第一排的人高，问排队的方案数</strong></p>
<p>将2*n个人排到两排当中，第二排视为左括号，第一排视为右括号，满足一个左括号对应一个右括号就代表左括号的人比右括号的人高，每排从高到矮满足方案数不重复，对应的意思就是（←左括号1）（←左括号2）和（←左括号2）（←左括号1）是等价的，这么想就又变成了括号配对问题，两排括号还原到一行中就是一个合法的括号配对<br>方案数就是<img src="http://latex.codecogs.com/gif.latex?h(n)"></p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
            <category> 组合数学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>https://kaikuxy.github.io/2017/03/19/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
