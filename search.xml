<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[今天的Coursera测验做了三次才对这说明对Precision和Recall的理解有问题]]></title>
      <url>https://kaikuxy.github.io/2017/03/26/%E4%BB%8A%E5%A4%A9%E7%9A%84Coursera%E6%B5%8B%E9%AA%8C%E5%81%9A%E4%BA%86%E4%B8%89%E6%AC%A1%E6%89%8D%E5%AF%B9%E8%BF%99%E8%AF%B4%E6%98%8E%E5%AF%B9Precision%E5%92%8CRecall%E7%9A%84%E7%90%86%E8%A7%A3%E6%9C%89%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>知道Precision和Recall是什么但是还是有点在区别的时候犯迷糊，加上这次的题目出的感觉有点模糊，有些描述有点模棱两可</p>
<p>用通俗点的话来描述Precision和Recall分别就是</p>
<p>Precision：判断的准确率，在你判断为真的数据中事实上就是真的比例</p>
<p>Recall：在所有为真的数据中你判断为真的比例,也就是你没有漏判的程度</p>
<p><strong>!!一般的，我们将数据中出现少的那一种情况定义为真!!</strong></p>
<p>也就是，假设我们使用了logistic regression，最后给的h(x)在[0, 1]，如果我们想更准确判断，那么会有更高的Precision，以及更低的Recall；而如果我们不想漏过某个为真的数据，那么会有更高的Recall，以及更低的Precision</p>
<p>因为我们取得的数据有可能会是skewed class，比如数据中99%的患者没有得癌症，而只有1%的患者得了癌症，这种情况下，单单使用accuracy来衡量某个学习算法是不好的，举一个反例就是我们可以让算法直接判断所有患者都没有得癌症，这样得到的accuracy达到了99%，但是这并不是我们想要的</p>
<p>因此我们使用F1score = (2 <em> Precision </em> Recall) / (Precision + Recall)来衡量</p>
<p>用上面那个例子，99%的患者没有得癌症</p>
<p>1&gt;   假设我们判断所有的患者都得了癌症，我们得到了100%的Recall因为我们没有漏过任何一个病例，另一方面，我们得到了1%的Precision，因为实际上只有1%的患者得了癌症，而总准确率为0.01</p>
<p>2&gt;   假设我们判断所有的患者都没有得癌症，我们得到了0%的Recall因为我们漏掉了所有病例，另一方面，我们得到了0%的Precision因为我们所有判断得癌症的准确率是0，而我们得总准确率却有0.99</p>
<p>我们在用F1score衡量的时候，会希望F1score越大越好。在最理想情况下，我们准确且未漏判所有得了癌症的患者，这个时候，我们的F1score为</p>
<p>F1score = (2 <em> 1 </em> 1) / (1 + 1) = 1</p>
<p>这么理了一下感觉清晰些了</p>
<p>PS：什么时候把前面学的也理一下呢</p>
]]></content>
      
        <categories>
            
            <category> MachineLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MachineLearning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[趣味と仕事、どちらが大事]]></title>
      <url>https://kaikuxy.github.io/2017/03/26/Debate-Interest-and-Work/</url>
      <content type="html"><![CDATA[<p>　生活するために、仕事をしなければならない。仕事がないと、生きるための金もない、生活するのも問題の状況で、趣味を発展する余裕はあるのか。そもそも、仕事ということは、生計を立てるために、自分の生活をより楽しくより幸福になるために、必要なことです。趣味を見つけて、愛し、発展し続けることもその「より楽しく、より幸福になる」にあるのです。つまり、仕事が趣味の存在を支持するのです。</p>
<p>　WIKIで、趣味という単語はこのように説明するのです：</p>
<pre><code>趣味は、以下の二つの意味を持つ。
１．人間が自由時間（生理的必要時間と労働時間を除いた時間、余暇）に、好んで習慣的に繰り返しおこなう行為、事柄やその対象のこと。
２．物の持つ味わい・おもむきを指し、それを鑑賞しうる能力（美しいものや面白いものについての好みや嗜好）のこと。
</code></pre><p>　つまり、趣味は、仕事が終わった後、時間があったらできるのです。このような説明方も、仕事の方が大事だということを私たちに教えてくれたのです。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 2376 GreedyAlgorithm]]></title>
      <url>https://kaikuxy.github.io/2017/03/26/poj-2376/</url>
      <content type="html"><![CDATA[<p>贪心</p>
<p>l为第一关键字，r为第二关键字排序</p>
<p>每次选择当前l合法的有最远的r的区间</p>
<p>很多，很多注意事项</p>
<ol>
<li>区间不需要覆盖，…, r] [r+1, … 就合法</li>
<li>数据给的最远r可能大于T</li>
<li>数据给的最近l可能大于1</li>
<li>可能存在[1, 1] [1, 2] [1, 3] …. 这种情况，所以不要直接先把第一个区间取了，特判到死</li>
</ol>
<p>第一版代码又臭又长，我也不知道为什么过这么久没写代码会用while里面还套while还重复判相同条件这种东西，还多出很多毫无意义的变量</p>
<p>教训：</p>
<ol>
<li>特判会让自己的代码又臭又长，还难读，能用一个循环绝不在开头加特判处理初始情况，纯属没事找事做</li>
<li>不要开毫无意义的变量，想想怎么样可以简单表达</li>
<li>读题读题读题读题读题读题读题</li>
<li>找反例不是让自己加特判的，是让自己的代码更普遍化，通用更多数据</li>
</ol>
<pre class=" language-C++"><code class="language-C++">#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <cmath>
#define Maxn 25000
using namespace std;
struct interval {
    int start, end;
}inter[Maxn + 10];
int N, T, ans;
bool cmp(interval, interval);
int main() {
    scanf("%d%d", &N, &T);
    for (int i = 0;i < N;++ i)
        scanf("%d%d", &inter[i].start, &inter[i].end);
    sort(inter, inter + N, cmp);
    /*for (int i = 0;i < N;++ i)
        printf("%d %d\n", inter[i].start, inter[i].end);*/
    int iter = 0, start, end = 0;
    while (end < T) {
        start = end + 1;
        for (int i = iter;i < N;++ i)
            if (inter[i].start <= start)
                end = max(end, inter[i].end);
            else {
                iter = i;
                break;
            }
        if (start > end) {
            ans = -1;
            break;
        }
        ++ ans;
    }
    printf("%d\n", ans);
    return 0;
}
bool cmp(interval x, interval y) {
    if(x.start != y.start)
        return x.start < y.start;
    else
        return x.end < y.end;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> POJ </category>
            
            <category> GreedyAlgorithm </category>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> POJ </tag>
            
            <tag> ACM </tag>
            
            <tag> GreedyAlgorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 2718 GreedyAlgorithm STL]]></title>
      <url>https://kaikuxy.github.io/2017/03/25/poj-2718/</url>
      <content type="html"><![CDATA[<p>做了一上午的2718，差点爆炸</p>
<p>做法一：<br>用到了STL中的next_permutation产生所有的全排列<br>要使生成的两个数差最小，两个数的位数差肯定小于等于1，产生一个排列之后在中间分开就可以</p>
<p>什么时候详细写一下STL里面产生全排列的写法</p>
<pre class=" language-C++"><code class="language-C++">/*
    next_permutation
*/
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <time.h>
using namespace std;

int t, cnt, ans;
char arr[10 + 1];
char input[20];

int make(int, int);

int main() {
    //clock_t start, end;
    //freopen("output.txt", "r", stdin);
    //freopen("out1.txt", "w", stdout);
    scanf("%d", &t);
    getchar();
    while (t --) {
        cnt = 0;
        gets(input);
        for (int i = 0;i < strlen(input);++ i)
            if (input[i] != ' ')
                arr[cnt ++] = input[i];
        //printf("cnt: %d\n", cnt);
        //start = clock();
        sort(arr, arr + cnt);
        //for (int i = 0;i < cnt;++ i)
            //printf("%d", arr[i]);
        ans = -1;
        do {
                if (arr[0] == '0' || arr[cnt / 2] == '0' && cnt > 2)
                    continue;
                int temp = abs(make(0, cnt / 2 - 1) - make(cnt / 2, cnt - 1));
                ans = (ans == -1 || ans > temp) ? temp : ans;
        } while(next_permutation(arr, arr + cnt));
        printf("%d\n", ans);
        //end = clock();
        //printf("time:%f\n", (double)(end - start) / CLOCKS_PER_SEC);
    }
    //fclose(stdin);
    //fclose(stdout);
    return 0;
}

int make(int a, int b) {
    int temp = 0;
    for(int i = a;i <= b;++ i)
        temp = temp * 10 + arr[i] - '0';
    return temp;
}
</code></pre>
<p>做法二：<br>分情况<br>如果是偶数的话，枚举所有两个相差最近的数当作两个生成的数的最高位，之后大数不断取剩下的数中最小的数当作下一位，小数不断取剩下的数中最大的数当作下一位，对于每个枚举更新下ans<br>如果是奇数的话，就不需要枚举最高位了，因为大的那个数最高位一定得取最小的数字，剩下和偶数做法一样不断取最小的数最大的数然后更新ans<br>然后需要注意在偶数枚举最高位的时候，不能考虑数字0，其他情况下先不考虑0到最后计算差值的时候如果0出现在第一位就和后面数字换一下位置就可以<br>我也不知道为什么贪心会WA那么多次，大概是我太菜了，把所有数据全部生成出来对比才发现问题，哎.什么时候还再回忆一下对拍咋写</p>
<p>代码又臭又长</p>
<pre class=" language-C++"><code class="language-C++">/*
    greedy
*/
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <time.h>
using namespace std;

int t, cnt, ans;
char arr[10];
char input[20], num1[10], num2[10];
bool use[10];
int cnt1, cnt2;

int make(char*, int, int);

int main() {
    //clock_t start, end;
    //freopen("output.txt", "r", stdin);
    //freopen("out2.txt", "w", stdout);
    scanf("%d", &t);
    getchar();
    while (t --) {
        ans = -1;
        cnt1 = cnt2 = 0;
        cnt = 0;
        gets(input);
        for (int i = 0;i < strlen(input);++ i)
            if (input[i] != ' ')
                arr[cnt ++] = input[i];
        //printf("cnt: %d\n", cnt);
        //start = clock();
        sort(arr, arr + cnt);
        //for (int i = 0;i < cnt;++ i)
            //printf("%d", arr[i]);
        /*
        do {
                if (arr[0] == '0' || arr[cnt / 2] == '0' && cnt > 2)
                    continue;
                int temp = abs(make(0, cnt / 2 - 1) - make(cnt / 2, cnt - 1));
                ans = (ans == -1 || ans > temp) ? temp : ans;
        } while(next_permutation(arr, arr + cnt));*/
            if(cnt == 2) {
                printf("%d\n", abs(arr[1] - arr[0]));
                continue ;
            }

            int Min = 10000;

            if(cnt % 2) {
                int temp = (cnt - ((cnt % 2) ? 0 : 2)) / 2 + 1;
                for (int i = 0;i < cnt && temp;++ i) {
                    num1[cnt1 ++] = arr[i];
                    -- temp;
                }
                temp = (cnt - ((cnt % 2) ? 0 : 2)) / 2;
                for (int i = cnt - 1;i >= 0 && temp;-- i) {
                    num2[cnt2 ++] = arr[i];
                    -- temp;
                }
                /*printf("Bigger: ");
                for (int j = 0;j < cnt1;++ j)
                    printf("%c ", num1[j]);
                printf("\n");
                printf("Smaller: ");
                for (int j = 0;j < cnt2;++ j)
                    printf("%c ", num2[j]);
                printf("\n");*/
                temp = abs(make(num1, 0, cnt1 - 1) - make(num2, 0, cnt2 - 1));
                ans = temp;
            }
            else {
                for (int i = 0;i < cnt - 1;++ i)
                    if (arr[i] != '0')
                        Min = min(Min, arr[i + 1] - arr[i]);
                for (int i = 0;i < cnt - 1;++ i)
                    if (arr[i] != '0') {
                        if (Min == arr[i + 1] - arr[i])
                        {
                            cnt1 = cnt2 = 0;
                            int temp;
                            memset(use, 0, sizeof(use));
                            use[i + 1] = use[i] = true;
                            num1[cnt1 ++] = arr[i + 1]; // bigger
                            num2[cnt2 ++] = arr[i]; // smaller

                            //printf("cnt1: %d    cnt2: %d\n", cnt1, cnt2);

                            temp = (cnt - ((cnt % 2) ? 0 : 2)) / 2;
                            for (int j = 0;j < cnt && temp;++ j)
                                if (!use[j]) {
                                    num1[cnt1 ++] = arr[j];
                                    -- temp;
                                }
                            temp = (cnt - ((cnt % 2) ? 0 : 2)) / 2;
                            for (int j = cnt - 1;j >= 0 && temp;-- j)
                                if (!use[j]) {
                                    num2[cnt2 ++] = arr[j];
                                -- temp;
                                }
                            /*for (int j = 0;j < cnt1;++ j)
                            printf("%c ", num1[j]);
                            printf("\n");
                            for (int j = 0;j < cnt2;++ j)
                            printf("%c ", num2[j]);
                            printf("\n");*/
                            temp = abs(make(num1, 0, cnt1 - 1) - make(num2, 0, cnt2 - 1));
                            //printf ("%d\n", temp);
                            ans = (ans == -1 || ans > temp) ? temp : ans;
                        }
                    }
            }
        printf("%d\n", ans);
        //end = clock();
        //printf("time:%f\n", (double)(end - start) / CLOCKS_PER_SEC);
    }
    //fclose(stdin);
    //fclose(stdout);
    return 0;
}

int make(char* s ,int a, int b) {
    int temp = 0;
    //printf("%c %c\n", *(s + a), *(s + a + 1));
    if(b - a > 0 && *(s + a) == '0') {
        char tempc = *(s + a);
        *(s + a) = *(s + a + 1);
        *(s + a + 1) = tempc;
    }
    for(int i = a;i <= b;++ i)
        temp = temp * 10 + *(s + i) - '0';
    return temp;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> POJ </category>
            
            <category> GreedyAlgorithm </category>
            
            <category> ACM </category>
            
            <category> STL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> POJ </tag>
            
            <tag> ACM </tag>
            
            <tag> GreedyAlgorithm </tag>
            
            <tag> STL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Haru!!]]></title>
      <url>https://kaikuxy.github.io/2017/03/23/Haru/</url>
      <content type="html"><![CDATA[<p>HARU!!!!!!</p>
<p><img src="/images/haru.gif" alt="这里写图片描述"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 1979 3669 BFS DFS]]></title>
      <url>https://kaikuxy.github.io/2017/03/23/poj-1979-3669/</url>
      <content type="html"><![CDATA[<p>一道DFS一道BFS</p>
<p>1979:</p>
<p>DFS无脑扫就可以了</p>
<pre class=" language-C++"><code class="language-C++">#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <cstring>
#define MaxW 20
using namespace std;

int W, H, ans;
char input;
bool sign[MaxW + 10][MaxW + 10];
pair <int, int> start;
bool tra[MaxW + 10][MaxW + 10];

void Tra(int, int);

int main() {
    while (scanf("%d%d", &W, &H), !(W == 0 && H == 0)) {
        ans = 0;
        getchar();
        memset(tra, 0, sizeof(tra));
        for (int i = 1;i <= H;++ i) {
            for (int j = 1;j <= W;++ j) {
                scanf("%c", &input);
                if(input == '.')    sign[i][j] = true;
                else if(input == '#')    sign[i][j] = false;
                else {
                    sign[i][j] = true;
                    start = make_pair(i, j);
                }
            }
            getchar();
        }
        Tra (start.first, start.second);
        printf("%d\n", ans);
    }
    return 0;
}

void Tra(int x, int y) {
    //printf ("%d %d\n", x, y);
    ++ ans;
    tra[x][y] = true;
    if(x + 1 <= H && sign[x + 1][y] && !tra[x + 1][y])
        Tra(x + 1, y);
    if(x - 1 >= 1 && sign[x - 1][y] && !tra[x - 1][y])
        Tra(x - 1, y);
    if(y + 1 <= W && sign[x][y + 1] && !tra[x][y + 1])
        Tra(x, y + 1);
    if(y - 1 >= 1 && sign[x][y - 1] && !tra[x][y - 1])
        Tra(x, y - 1);
}
</code></pre>
<p>问题就出在3669上</p>
<p>做法没什么好说的，预处理每个点最早被流星破坏的时间入队前判断一下当前时间是否在最早被流星破坏的时间前就可以了<br>然后注意题目中给的数据范围是流星坠落的数据范围，并不是整块地的<br>所以要再开大一点<br>然后T了3，4次<br>最后终于发现了问题<br>在每次入队的时候先把visit给标记了，要不然会多出很多很多相同的冗余元素在队里面，因为bfs和dfs不一样，bfs会一层中一次性入很多元素</p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#define INF 3000
#define Maxx 300
using namespace std;

struct elem {
    int a, b, time;
};

int m, x, y, t, ans;
int destr[Maxx + 10][Maxx + 10];
bool tra[Maxx + 10][Maxx + 10];
int dx[5] = {1, -1, 0, 0, 0};
int dy[5] = {0, 0, 1, -1, 0};

int main() {
    ans = -1;
    scanf(&quot;%d&quot;, &amp;m);
    for (int i = 0;i &lt; Maxx + 10;++ i)
        for (int j = 0;j &lt; Maxx + 10;++ j)
            destr[i][j] = INF;
    for (int i = 1;i &lt;= m;++ i) {
        scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;t);
        for (int j = 0;j &lt; 5;++ j)
        {
            int xx = x + dx[j], yy = y + dy[j];
            if(xx &gt;= 0 &amp;&amp; yy &gt;= 0)
                destr[xx][yy] = min(destr[xx][yy], t);
        }
    }
    if (destr[0][0] == 0) {
        printf(&quot;-1\n&quot;);
        return 0;
    }
    if (destr[0][0] == INF) {
        printf(&quot;0\n&quot;);
        return 0;
    }
    queue &lt;elem&gt; timeline;
    elem start;    start.a = 0, start.b = 0, start.time = 0;
    timeline.push(start);
    while(!timeline.empty()) {
        elem temp = timeline.front();
        timeline.pop();
        //tra[temp.a][temp.b] = true;

        for(int i = 0;i &lt; 4;++ i) {
            int xx = temp.a + dx[i], yy = temp.b + dy[i], tt = temp.time + 1;
            if(xx &gt;= 0 &amp;&amp; yy &gt;= 0 &amp;&amp; destr[xx][yy] &gt; tt &amp;&amp; !tra[xx][yy]) {
                tra[xx][yy] = true;
                if (destr[xx][yy] == INF) {
                    printf(&quot;%d\n&quot;, tt);
                    return 0;
                }
                start.a = xx;
                start.b = yy;
                start.time = tt;
                timeline.push(start);
            }
        }
    }
    printf(&quot;-1\n&quot;);
    return 0;
}
</code></pre>]]></content>
      
        <categories>
            
            <category> POJ </category>
            
            <category> BFS </category>
            
            <category> DFS </category>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> POJ </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
            <tag> ACM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[bbctest]]></title>
      <url>https://kaikuxy.github.io/2017/03/21/bbctest/</url>
      <content type="html"><![CDATA[<p><iframe width="400" height="500" frameborder="0" src="http://www.bbc.co.uk/programmes/p04xfxhz/player"></iframe> </p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[math]]></title>
      <url>https://kaikuxy.github.io/2017/03/21/math/</url>
      <content type="html"><![CDATA[<p>simple line $a = b + c$</p>
<p>$\frac{\partial u}{\partial t} = h^2 \left( \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} + \frac{\partial^2 u}{\partial z^2}\right)$</p>
<p>$$<br>\frac{\partial u}{\partial t} = h^2 \left( \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} + \frac{\partial^2 u}{\partial z^2}\right)<br>$$</p>
<p>$$<br>h(n) = h(0) * h(n - 1) + h(1) + b + c + d + e + f + h(n - 3)<br>$$</p>
<p>$$<br>h(n) = h(0) <em> h(n - 1) + h(1) + b + c + d + e + f + h(n - 3) </em> h(n - 4)<br>$$</p>
<p>h(n) = h(0) <em> h(n - 1) + h(1) + b + c + d + e + f + h(n - 3) </em> h(n - 4)</p>
<p>h(n) = h(0) <em> h(n - 1) + h(1) </em> h(n - 2) + … + h(n - 1) * h(0)</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Catalan数]]></title>
      <url>https://kaikuxy.github.io/2017/03/20/Catalan%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>上个星期数据结构出了一道题目，给定4个数1,2,3,4入栈序列，问可能的出栈序列，以及出栈序列有哪些。<br>因为只要求4个元素的答案，所以直接手写判断了，判断方法按照栈的性质来，对于一个待判断的序列，需要满足对于所有元素，在这个元素之后出现的所有比他先入栈的（在这里给出了就是元素1234所以就是比他小的）应满足后入先出的规则（在这里就是满足递减）。这样就很容易判断出哪些是合法的出栈序列了。<br>我们知道了对于每个序列如何判断是否合法，那么对于一个n个元素的序列，他的所有合法的出栈序列有多少个呢？</p>
<p>先来看另一个问题：</p>
<p>对于n对括号()，有多少种匹配方式？( n = 2的情况：()() 或者 (())两种 )</p>
<p>很容易想到可以从n-1对括号推过来<br>（….）….<br>括号内以及括号外是已经匹配完成的n-1对括号，括号内括号对数可以为0,1,2,…..,n-1<br>得出递推式</p>
<blockquote>
<p><img src="http://latex.codecogs.com/gif.latex?h(n) = \sum_{i=0}^{n-1}h(i)*h(n-1-i)"><br>h(n)为n对括号匹配方式</p>
</blockquote>
<p>数列h(n)就是Catalan数列，前几项是1,1,2,5,14,42,132,429,1430,4862,16796<br>上面是递推式，直接求h(n)的话就是：</p>
<blockquote>
<p><img src="http://latex.codecogs.com/gif.latex?h(n)=\frac{1}{n+1}\binom{2n}{n}"></p>
</blockquote>
<p>我们再来看刚刚的n元素出栈序列种数问题<br>每一个合法的出栈序列都对应一个合法的入栈序列，那么可以把入栈当作左括号，出栈当作右括号。不管入栈出栈元素是哪一个，某一个入栈出栈序列合法的条件是每次出栈前面必定一一对应着一个入栈的元素，可以发现这和n对括号匹配的问题是一样的。</p>
<p>答案就很明显了，n元素出栈序列种数为<img src="http://latex.codecogs.com/gif.latex?h(n)"></p>
<p>再来看一些关于Catalan数的问题：</p>
<p><strong>1. <img src="http://latex.codecogs.com/gif.latex?P=A1*A2*\cdots*An">，问有多少种计算先后顺序方案</strong></p>
<p>运用结合律形成各种计算先后顺序，相当于加上若干个括号，同样运用递推的思想得出</p>
<blockquote>
<p><img src="http://latex.codecogs.com/gif.latex?f(n) = \sum_{i=1}^{n-1}f(i)*f(n-i)"><br><img src="http://latex.codecogs.com/gif.latex?f(n)=h(n-1)"></p>
</blockquote>
<hr>
<p><strong>2.n个结点的二叉树，有多少种形态</strong></p>
<p>相当于在当前根下左子树种数*右子树种数，直接得出</p>
<blockquote>
<p><img src="http://latex.codecogs.com/gif.latex?f(n) = \sum_{i=0}^{n-1}f(i)*f(n-1-i)"></p>
</blockquote>
<hr>
<p><strong>3.在圆上选择<img src="http://latex.codecogs.com/gif.latex?2*n"> 个点，将这些点成对连起来形成n条线段，求满足这n条线段不想交的方案数</strong></p>
<p>任意选择一个点开始，在剩下n-1个点中选取的点应满足由这两个点形成的线段两边都有偶数个。假设如果一边有奇数个，那么这边一定有一个点被剩下来使得它只有和其他线段相交才能到另一边与其他点连接成一条线段。<br>记<img src="http://latex.codecogs.com/gif.latex?f(n)"> 为选择n个点满足题目要求的方案数<br>根据上面所说可以得出递推式</p>
<blockquote>
<p><img src="http://latex.codecogs.com/gif.latex?f(n) = \sum_{i=0}^{\frac{n-2}{2}}f(i*2)*f(n-2-i*2)"></p>
</blockquote>
<p>发现<img src="http://latex.codecogs.com/gif.latex?f(n)=h(\frac{n}{2})"></p>
<hr>
<p><strong>4. n个点的凸多边形，划分成一个个三角形区域的方案数</strong></p>
<p>显然最后划分成的所有三角形中存在一个三角形它的两个点是相邻的。不妨假设我们对于当前凸多边形选取某两个相邻的点当作三角形的期中两个点，我们需要寻找剩下一个点来形成一个三角形<br>很容易发现，当我们将某个点设为这个三角形剩下的一个点的时候，这个凸多边形被我们划分成了三块，一块是我们划分出的三角形，另两块为分布在该三角形两边的凸多边形，那么方案数就是</p>
<blockquote>
<p>左边凸多边形划分三角形的方案数*右边凸多边形的方案数</p>
</blockquote>
<p> 记<img src="http://latex.codecogs.com/gif.latex?f(n)"> 为n个点的凸多边形划分三角形的方案数，我们记</p>
<blockquote>
<p><img src="http://latex.codecogs.com/gif.latex?f(2)=1,f(3)=1"><br>（当<img src="http://latex.codecogs.com/gif.latex?n=2"> 时，意味着在上一层划分时三个点是相邻的）</p>
</blockquote>
<p>得出递推式</p>
<blockquote>
<p><img src="http://latex.codecogs.com/gif.latex?f(n)=f(2)*f(n-1)+f(3)*f(n-2)+\cdots+f(n-1)*f(2)"></p>
</blockquote>
<p>发现<img src="http://latex.codecogs.com/gif.latex?f(n)=h(n-2)"></p>
<hr>
<p><strong>5. wiki上的一个：在一个n*n的格子中，从左下出发到右上，每次只能向右或者向上走一个格子的一条边，不能跨过左下到右上的对角线，求行动方案数</strong></p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f4/Catalan_number_4x4_grid_example.svg/450px-Catalan_number_4x4_grid_example.svg.png" alt="这里写图片描述"></p>
<p>我们知道走到右上行动次数一定是n次向右与n次向上，不能跨过对角线的意思就是行动当前向上行动的次数不能大于向右行动的次数。<br>其实就和括号配对的问题是一样的了，方案数就是<img src="http://latex.codecogs.com/gif.latex?h(n)"></p>
<hr>
<p><strong>6. 还有一个贴切生活的问题：<img src="http://latex.codecogs.com/gif.latex?2*n"> 个人排队进入剧院，入场费5元，n个人只有5元钞票，剩下n个人只有10元钞票，收银员当前没有供找零的钱，问可行的排队方案（一点都不贴切生活）</strong></p>
<p>和括号配对也是一样，只有5元钞票的人视为入栈，只有10元钞票的人必须找零5元，相当于出栈，那么方案数就是<img src="http://latex.codecogs.com/gif.latex?h(n)"></p>
<hr>
<p><strong>7. 2*n个人排队，排成两排，每排从左到右从高到矮，第二排的人比第一排的人高，问排队的方案数</strong></p>
<p>将2*n个人排到两排当中，第二排视为左括号，第一排视为右括号，满足一个左括号对应一个右括号就代表左括号的人比右括号的人高，每排从高到矮满足方案数不重复，对应的意思就是（←左括号1）（←左括号2）和（←左括号2）（←左括号1）是等价的，这么想就又变成了括号配对问题，两排括号还原到一行中就是一个合法的括号配对<br>方案数就是<img src="http://latex.codecogs.com/gif.latex?h(n)"></p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
            <category> 组合数学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>https://kaikuxy.github.io/2017/03/19/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span>
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
